<html>
<head>
  <title>Recover your BitGo wallet</title>
  <script src="js/bitcoinjs-lib.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/sjcl/1.0.0/sjcl.min.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.10.1/lodash.min.js"></script>
  <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet">
</head>
<body>
<script>



  var ADDRESS_LOOKAHEAD = 20;
  var FEE_PER_KB = 0.0001 * 1e8;

  var network = bitcoin.networks.bitcoin;
  var BLOCKR_API_BASE_URL = "https://btc.blockr.io/api/v1";

  // vars to verify user is sending the correct amount to the correct address
  var SEND_AMOUNT;
  var FEE_AMOUNT;
  var RECEIVE_ADDRESS;

  // Uncomment for testnet
  // var network = bitcoin.networks.testnet;
  // var BLOCKR_API_BASE_URL = "https://tbtc.blockr.io/api/v1";

  var keys = [];
  var addresses = {};
  var unspents = [];
  var txSigningRequest = {};

  var appendLog = function(text) {
    $('#console').val($('#console').val() + "\n" + text);
    $('#console').scrollTop($('#console')[0].scrollHeight - $('#console').height());
  };

  var deriveKeys = function(keyArray, index) {
    var results = [];
    keyArray.forEach(function(k) {
      results.push(k.derive(index));
    });
    return results;
  };

  var createMultiSigAddress = function(keyArray)  {
    var publicKeys = [];
    keyArray.forEach(function(k) {
      publicKeys.push(k.pubKey);
    });

    var redeemScript = bitcoin.scripts.multisigOutput(2, publicKeys);
    var scriptHashScript = bitcoin.scripts.scriptHashOutput(redeemScript.getHash());
    var address = bitcoin.Address.fromOutputScript(scriptHashScript, network);
    address.redeemScript = redeemScript;
    return address;
  };

  var setKeyCardInputDisableProperties = function(state) {
    $("#boxa").prop('disabled', state);
    $("#boxb").prop('disabled', state);
    $("#passphrase").prop('disabled', state);
    $("#destinationAddress").prop('disabled', state);
    $("#btnStartRecovery").prop('disabled', state);
  };

  var setRecoveryRequestInputDisableProperties = function(state) {
    $("#message").prop('disabled', state);
    $("#btnSendRecoveryRequest").prop('disabled', state);
  };

  var formatBTCFromSatoshis = function(satoshis) {
    return (satoshis * 1e-8).toFixed(4);
  };

  var startRecovery = function() {
    $("#console").animate({ height: "70%" }, 1000);
    $("html, body").animate({ scrollTop: $(document).height() }, 1000);

    var userKey = $('#boxa').val();
    var backupKey = $('#boxb').val();
    var destinationAddress = $("#destinationAddress").val();

    setKeyCardInputDisableProperties(true);
    $('#console').val('Starting recovery.');

    if (!$('#passphrase').val()) {
      appendLog("please enter your wallet password in the 'Wallet passcode' field");
      return setKeyCardInputDisableProperties(false);
    }
    // Validate the user key
    try {
      userKey = sjcl.decrypt($('#passphrase').val(), $('#boxa').val());
      var userHDNode = bitcoin.HDNode.fromBase58(userKey);
      keys.push(userHDNode);
      appendLog("Successfully decrypted and parsed user key with xpub: " + userHDNode.neutered().toBase58() + '\n');
    } catch (e) {
      appendLog("Failed to decrypt user key with passcode - try again!");
      return setKeyCardInputDisableProperties(false);
    }

    // Validate the backup key
    try {
      backupKey = sjcl.decrypt($('#passphrase').val(), $('#boxb').val());
      var backupHDNode = bitcoin.HDNode.fromBase58(backupKey);
      keys.push(backupHDNode);
      appendLog("Successfully decrypted and parsed backup key with xpub: " + backupHDNode.neutered().toBase58() + '\n');
    } catch (e) {
      appendLog("Failed to decrypt backup key with passcode - try again!");
      return setKeyCardInputDisableProperties(false);
    }

    // Validate the destination address
    try {
      bitcoin.Address.fromBase58Check(destinationAddress, network);
      appendLog("Successfully parsed destination address: " + destinationAddress + '\n');
    } catch (e) {
      appendLog("Invalid destination bitcoin address!");
      return setKeyCardInputDisableProperties(false);
    }

    // delay 10ms to allow UI to update
    setTimeout(function() {
      collectUnspents(keys, function() {
        craftTransaction(destinationAddress, function() {
          // Check TX by decoding via API:
          appendLog("Querying blockr.io API to verify tx..");
          $.ajax({
            type: "POST",
            url: BLOCKR_API_BASE_URL + "/tx/decode",
            cache: false,
            dataType: "json",
            data: JSON.stringify({ "hex" : txSigningRequest.transactionHex }),
            success: function(response) {
              var stats = response.data.statistics;
              var blockrReceiveAddress = response.data.tx.vout[0].scriptPubKey.addresses[0];
              appendLog("TX as described by blockr.io: \n\n");
              appendLog(JSON.stringify(response.data, null, '\t'));
              appendLog("Please verify the transaction. If it is acceptable, type the following message in the field below to acknowledge you understand the effects of continuing with recovery.\n\n");
              appendLog("I agree to send " + stats.vouts_sum + " BTC with a fee of " + stats.fee + " BTC to address " + blockrReceiveAddress + '\n');

              SEND_AMOUNT = stats.vouts_sum;
              FEE_AMOUNT = stats.fee;
              RECEIVE_ADDRESS = blockrReceiveAddress;
              $('#sendSection').show(1000);
            }
          });
        });
      });
    }, 10);
  };

  var collectUnspents = function(keys, completedUnspentsCallback) {
    appendLog("Now deriving wallet ID..");
    appendLog("============================================================");
    // BitGo's key derivation paths are /0/0/0/i for user-generated addresses and /0/0/1/i for change adddresses.
    // Derive these top level paths first for performance reasons
    var keys_0_0 = deriveKeys(deriveKeys(keys, 0), 0);
    var keys_0_0_0 = deriveKeys(keys_0_0, 0);
    var keys_0_0_1 = deriveKeys(keys_0_0, 1);

    // We want to get the wallet id, which is the first /0/0/0/0.
    var walletAddress = createMultiSigAddress(deriveKeys(keys_0_0_0, 0));
    appendLog("The wallet ID detected was: " + walletAddress.toBase58Check());
    appendLog("============================================================");

    var queryBlockchainUnspents = function(keyArray, basePath, index, done) {
      var lookupThisBatch = [];
      for(var i = index; i < index + ADDRESS_LOOKAHEAD; i++) {
        // Derive the address
        var derivedKeys = deriveKeys(keyArray, i);
        var address = createMultiSigAddress(derivedKeys);
        var addressBase58 = address.toBase58Check();
        appendLog("Trying address #" + i + ": " + addressBase58);
        lookupThisBatch.push(addressBase58);

        address.chainPath = basePath + "/" + i;
        address.userKey = derivedKeys[0];
        address.backupKey = derivedKeys[1];
        addresses[addressBase58] = address;
      }

      var url = BLOCKR_API_BASE_URL + "/address/unspent/" + lookupThisBatch.join(",");
      // appendLog("URL: " + url);

      // Make async call to blockr.io
      $.ajax({
        type: "GET",
        url: url,
        cache: false,
        dataType: "json",
        success: function(response) {
          var resultsWithUnspents = _.filter(response.data, function(singleAddressResult) { return singleAddressResult.unspent && singleAddressResult.unspent.length > 0; });
          _.forEach(resultsWithUnspents, function(singleAddressResult) {
            _.forEach(singleAddressResult.unspent, function(singleUnspent) {
              singleUnspent.address = singleAddressResult.address;
              singleUnspent.amount = Math.round(parseFloat(singleUnspent.amount)*1e8); // perform all handling in satoshis from here onwards
              unspents.push(singleUnspent);
              appendLog("Found " + formatBTCFromSatoshis(singleUnspent.amount) + " BTC in " + singleUnspent.address + " (" + singleUnspent.tx + ")");
            });
          });
          // appendLog(JSON.stringify(resultsWithUnspents, null, '\t'));

          // If we found some unspents, then we should continue searching
          if (resultsWithUnspents.length > 0) {
            queryBlockchainUnspents(keyArray, basePath, index + ADDRESS_LOOKAHEAD, done);
          } else {
            // No more unspents found after the lookahead, so finish up searching in this chain
            done();
          }
        }
      });
    };

    appendLog("Getting unspents on chain 0 (user created addresses).. ");
    queryBlockchainUnspents(keys_0_0_0, "/0/0/0", 0, function() {
      appendLog("Getting unspents on chain 1 (change).. ");
      queryBlockchainUnspents(keys_0_0_1, "/0/0/1", 0, completedUnspentsCallback);
    });
  };

  var craftTransaction = function(destinationAddress, done) {
    var totalInputAmount = _.sum(unspents, function(u) { return u.amount; });
    if (totalInputAmount <= 0) {
      appendLog("No input to recover - aborting!");
      return setKeyCardInputDisableProperties(false);
    }
    appendLog("Total number of inputs: " + unspents.length + ". ");
    appendLog("Total amount found in inputs: " + formatBTCFromSatoshis(totalInputAmount) + " BTC. ");

    var approximateSize = new bitcoin.Transaction().toBuffer().length + (232 * unspents.length);
    var approximateFee = ((Math.floor(approximateSize / 1024)) + 1) * FEE_PER_KB;

    appendLog("Now constructing tx.. ");
    // Construct a transaction
    var transactionBuilder = new bitcoin.TransactionBuilder(network);
    txSigningRequest.inputs = [];
    _.forEach(unspents, function(unspent) {
      var address = addresses[unspent.address];
      transactionBuilder.addInput(unspent.tx, unspent.n, 0xffffffff, bitcoin.Script.fromHex(unspent.script));
      txSigningRequest.inputs.push({ chainPath: address.chainPath, redeemScript: address.redeemScript.toHex() });
    });
    transactionBuilder.addOutput(destinationAddress, totalInputAmount - approximateFee);

    // Sign the inputs
    appendLog("Signing tx.. \n");
    var i=0;
    _.forEach(unspents, function(unspent) {
      var address = addresses[unspent.address];
      transactionBuilder.sign(i, address.backupKey.privKey, address.redeemScript, bitcoin.Transaction.SIGHASH_ALL);
      transactionBuilder.sign(i++, address.userKey.privKey, address.redeemScript, bitcoin.Transaction.SIGHASH_ALL);
    });

    txSigningRequest.transactionHex = transactionBuilder.build().toBuffer().toString('hex');
    appendLog("Raw TX: " + txSigningRequest.transactionHex + '\n\n\n');
    done();
  };

  var sendRecoveryRequest = function() {
    // verify user message
    var userMessage = $("#message").val();
    if (userMessage !== "I agree to send " + SEND_AMOUNT + " BTC with a fee of " + FEE_AMOUNT + " BTC to address " + RECEIVE_ADDRESS) {
      appendLog("incorrect acknowledgement message! Type the correct message, BTC amounts and receive address to continue with recovery\n");
    } else {
      appendLog("Sending recovery request to Blockr.io...\n");
      $.ajax({
        type: "POST",
        cache: false,
        dataType: "json",
        url: BLOCKR_API_BASE_URL + "/tx/push",
        data: JSON.stringify({hex: txSigningRequest.transactionHex}),
        success: function(response) {
          appendLog("Transaction sent! Once the transaction is confirmed (usually 10 minutes) check " + RECEIVE_ADDRESS + " to make sure your coin arrived");
          appendLog("Thank you for using BitGo's recovery tool!\n");
          appendLog("Transaction ID: " + JSON.stringify(response.data));
        }
      });
    }
  }

</script>
<div class="jumbotron jumbotron-sm">
  <div class="container">
    <div class="row">
      <div class="col-sm-12 col-lg-12">
        <h1 class="h1">
          BitGo Wallet Recovery
        </h1>
          <h3 class="h3">
            This page is hosted on ______
          </h3>
        </h1>
      </div>
    </div>
  </div>
</div>
<div class="container">
  <form>
    <div class="row">
      <div class="col-md-12">
        <div class="well well-sm">
          <div class="row">
            <div class="col-md-12">
              <div class="form-group">
                <label for="passphrase">
                  Wallet passcode</label>
                <input type="password" class="form-control" id="passphrase" placeholder="The password of the wallet you're recovering" required="required" />
              </div>
              <div class="form-group">
                <label for="boxa">
                  User Private Key (Box A on BitGo Keycard)</label>
                <input type="text" class="form-control" id="boxa" placeholder="This is your private key, encrypted with your passcode" required="required" />
              </div>
              <div class="form-group">
                <label for="boxb">
                  Backup Key (Box B on BitGo Keycard)</label>
                <input type="text" class="form-control" id="boxb" placeholder="This is your backup private key, encrypted with your passcode" required="required" />
              </div>
              <div class="form-group">
                <label for="destinationAddress">
                  Destination Recovery Address</label>
                <input type="text" class="form-control" id="destinationAddress" placeholder="The bitcoin address to send recovered funds" required="required" />
              </div>
            </div>
            <div class="col-md-12">
              <button type="button" class="btn btn-primary pull-right" onclick="startRecovery(); return false;" id="btnStartRecovery">
                Begin Wallet Recovery</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </form>
  <div class="row">
    <div class="col-md-12">
      <form>
        <div class="well well-sm">
          <div class="row">
            <div class="col-md-12">
              <div class="form-group">
                <label for="name">
                  Message Console</label>
                  <textarea name="console" id="console" disabled class="form-control" rows="9" cols="25" style="resize:vertical">
This tool intentionally has no dependencies on the BitGo platform API. It uses an external API (blockr.io) for retrieving blockchain data. This is in order to demonstrate that Bitcoin stored in wallets created through the BitGo service can be recovered independently of BitGo, using only the KeyCard provided when creating a wallet on BitGo along with the wallet password.

If you are trying to recover a live BitGo wallet due to a lost password, please use the online wallet recovery functionality available inside the BitGo interface. Contact support@bitgo.com for assistance.
                  </textarea>
              </div>
            </div>
            <div id="sendSection" style="display:none;">
              <div class="col-md-12">
                <div class="row">
                  <div class="col-md-9">
                    <div class="form-group">
                      <input type="text" class="form-control" id="message" placeholder="I agree to send..." />
                    </div>
                  </div>
                  <div class="col-md-3">
                    <button type="button" class="btn btn-primary pull-right" onclick="sendRecoveryRequest(); return false;" id="btnSendRecoveryRequest">Send Recovery Request</button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </form>
    </div>
  </div>
</div>

</body>
</html>